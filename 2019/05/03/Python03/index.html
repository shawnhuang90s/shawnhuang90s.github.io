<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Python 基础知识(三)"><meta name="keywords" content="Python"><meta name="author" content="shawnhuang90s"><meta name="copyright" content="shawnhuang90s"><title>Python 基础知识(三) | Shawnhuang90s' Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5dab6484be977b815f981156440c8d81";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-139390935-1', 'auto');
ga('send', 'pageview');</script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=66402713";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#深浅-COPY"><span class="toc-number">1.</span> <span class="toc-text">深浅 COPY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#id-is-与-的区别"><span class="toc-number">2.</span> <span class="toc-text">id  is  与 == 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码块的缓存机制"><span class="toc-number">3.</span> <span class="toc-text">代码块的缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小数据池"><span class="toc-number">4.</span> <span class="toc-text">小数据池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码"><span class="toc-number">5.</span> <span class="toc-text">编码</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.postimg.cc/yxvCyRT3/avatar.jpg"></div><div class="author-info__name text-center">shawnhuang90s</div><div class="author-info__description text-center">Python  Django  Linux  Mysql  项目部署</div><div class="follow-button"><a href="https://github.com/shawnhuang90s">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://molunerfinn.com">Molunerfinn</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/shawnhuang">MyBlog</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.postimg.cc/MHJ94GhS/timg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Shawnhuang90s' Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Python 基础知识(三)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python-基础/">Python 基础</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><ul>
<li>深浅 <code>COPY</code></li>
<li>id  is  与 == 的区别</li>
<li>代码块的缓存机制</li>
<li>小数据池</li>
<li>编码</li>
</ul>
<a id="more"></a>
<h2 id="深浅-COPY"><a href="#深浅-COPY" class="headerlink" title="深浅 COPY"></a>深浅 COPY</h2><ol>
<li><p>赋值运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">"barry"</span>, <span class="string">"alex"</span>]]</span><br><span class="line">l2 = l1</span><br><span class="line"></span><br><span class="line">l1[<span class="number">0</span>] = <span class="number">111</span></span><br><span class="line">print(l1)    		<span class="comment"># [111, 2, 3, ['barry', 'alex']]</span></span><br><span class="line">print(l2)    		<span class="comment"># [111, 2, 3, ['barry', 'alex']]</span></span><br><span class="line">print(id(l1))		<span class="comment"># 2388049128072</span></span><br><span class="line">print(id(l2))		<span class="comment"># 2388049128072</span></span><br><span class="line"></span><br><span class="line">l1[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">"abc"</span></span><br><span class="line">print(l1)    		<span class="comment"># [111, 2, 3, ['abc', 'alex']]</span></span><br><span class="line">print(l2)    		<span class="comment"># [111, 2, 3, ['abc', 'alex']]</span></span><br><span class="line">id(l1)			<span class="comment"># 2388049128072</span></span><br><span class="line">id(l2)			<span class="comment"># 2388049128072</span></span><br><span class="line"></span><br><span class="line">l2[<span class="number">1</span>] = <span class="string">"askj"</span></span><br><span class="line">print(l1)    		<span class="comment"># [111, 'askj', 3, ['abc', 'alex']]</span></span><br><span class="line">print(l2)    		<span class="comment"># [111, 'askj', 3, ['abc', 'alex']]</span></span><br><span class="line">id(l1)			<span class="comment"># 2388049128072</span></span><br><span class="line">id(l2)			<span class="comment"># 2388049128072</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由上面两个示例得知, 两个列表指向的是同一个内存地址</span></span><br><span class="line"><span class="comment"># 所以它们是完全一样的，其中一个列表内元素的改变会导致另一个列表的改变</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>浅 <code>COPY</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l3 = [<span class="number">1</span>, <span class="string">"拷贝"</span>, <span class="literal">True</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), [<span class="number">123</span>, <span class="string">"ak"</span>]]</span><br><span class="line">l4 = l3.copy()</span><br><span class="line"></span><br><span class="line">print(id(l3), id(l4))</span><br><span class="line"><span class="comment"># 2862385252936  2862385260296   id 不一样</span></span><br><span class="line"></span><br><span class="line">print(id(l3[<span class="number">1</span>]), id(l4[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># 2862384610800  2862384610800   id 一样</span></span><br><span class="line"></span><br><span class="line">print(id(l3[<span class="number">-1</span>])), id(l4[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 2862385259720  2862385259720   id 一样</span></span><br><span class="line"></span><br><span class="line">print(id(l3[<span class="number">-2</span>])), id(l4[<span class="number">-2</span>])</span><br><span class="line"><span class="comment"># 2862385086400  2862385086400   id 一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现列表 l3 和 l4 在内存中指向不同的地址</span></span><br><span class="line"><span class="comment"># 但是它们同一个索引位置的元素指向内存中同一个地址</span></span><br><span class="line"><span class="comment"># 说明新列表中的元素与原列表中的元素是公用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅 copy 只是 copy 了一个外壳</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="string">"da"</span>, [<span class="number">22</span>, <span class="number">33</span>]]</span><br><span class="line">b = a.copy()</span><br><span class="line">a[<span class="number">-1</span>].append(<span class="number">44</span>)</span><br><span class="line">print(b)    <span class="comment"># [1, "da", [22, 33, 44]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是记住 a 和 b 的 id 是不一样的！</span></span><br><span class="line"><span class="comment"># 因此对其中一个列表的增删改查不会影响另一个列表的元素</span></span><br><span class="line"><span class="comment"># 比如接着上面</span></span><br><span class="line">a.append(<span class="number">33</span>)</span><br><span class="line">print(a)    <span class="comment"># [1, "da", [22, 33，44], 33]</span></span><br><span class="line">print(b)    <span class="comment"># [1, "da", [22, 33, 44]]</span></span><br><span class="line"><span class="comment"># 注意 a.append(33) 与 a[-1].append(44) 的区别！</span></span><br><span class="line"><span class="comment"># 一个是给列表添加元素，另一个是给列表中的元素(即列表)里添加一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里涉及到切片的相关知识</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">22</span>, <span class="number">33</span>]]</span><br><span class="line">l2 = l1[::]</span><br><span class="line">l1[<span class="number">-1</span>].append(<span class="number">666</span>)</span><br><span class="line">print(l2)   <span class="comment"># [1, 2, 3, [22, 33, 666]</span></span><br><span class="line"><span class="comment"># 这说明对列表创建一个副本是 浅 copy!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>深 <code>COPY</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">l5 = [<span class="number">3</span>, <span class="literal">True</span>, <span class="string">"ask"</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), [<span class="number">34</span>, <span class="string">"as"</span>]]</span><br><span class="line">l6 = copy.deepcopy(s5)</span><br><span class="line"></span><br><span class="line">print(id(l5), id(l6))  </span><br><span class="line"><span class="comment"># 2862386662664  2862386819848	id 不一样</span></span><br><span class="line"></span><br><span class="line">print(id(l5[<span class="number">0</span>]), id(l6[<span class="number">0</span>]))  </span><br><span class="line"><span class="comment"># 1409182528  1409182528	    id 一样</span></span><br><span class="line"></span><br><span class="line">print(id(l5[<span class="number">-1</span>]), id(l6[<span class="number">-1</span>]))  </span><br><span class="line"><span class="comment"># 2862386662600  2862386819912	id 不一样</span></span><br><span class="line"></span><br><span class="line">print(id(l5[<span class="number">-2</span>]), id(l6[<span class="number">-2</span>]))  </span><br><span class="line"><span class="comment"># 2862385217680  2862385217680	id 一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于深copy，列表是在内存中重新创建的。</span></span><br><span class="line"><span class="comment"># 列表中可变的数据类型是重新创建的，列表中的不可变数据类型是公用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这三个列表之间都算是深copy</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">33</span>, <span class="number">44</span>]]</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">33</span>, <span class="number">44</span>]]</span><br><span class="line"><span class="comment"># 这三者中，可变的数据类型是重新创建的，不可变数据类型是公用的</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="id-is-与-的区别"><a href="#id-is-与-的区别" class="headerlink" title="id  is  与 == 的区别"></a>id  is  与 == 的区别</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"ad"</span></span><br><span class="line">print(id(name))    </span><br><span class="line"><span class="comment"># 2738647174536</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is —— 比较两边的内存地址是否相等</span></span><br><span class="line"><span class="comment"># == —— 比较两边的数值是否相等</span></span><br><span class="line">i1 = <span class="number">1000</span></span><br><span class="line">i2 = <span class="number">1000</span></span><br><span class="line">print(i1 <span class="keyword">is</span> i2)</span><br><span class="line"><span class="comment"># 如果是在终端内一步一步输入上面的内容，则相当于 i1 与 i2 是两个代码块，结果就是 False</span></span><br><span class="line"><span class="comment"># 反之像现在这样在同一个代码块里的话，结果就是 True</span></span><br><span class="line"><span class="comment"># 这里所说的代码块可以理解为一个文件就是一个代码块</span></span><br><span class="line"><span class="comment"># 在终端里一行 "&gt;&gt;&gt;" 代表一个代码块</span></span><br><span class="line">print(i1 == i2)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果内存地址相同，值一定相同，反之则不一定。</span></span><br></pre></td></tr></table></figure>
<h2 id="代码块的缓存机制"><a href="#代码块的缓存机制" class="headerlink" title="代码块的缓存机制"></a>代码块的缓存机制</h2><ol>
<li><p>代码块是作为一个单元执行的，这个单元可以是一个模块，一个函数，一个类</p>
</li>
<li><p>代码块的缓存机制：</p>
<ul>
<li><p><code>Python</code> 在执行同一个代码块的初始化对象（也就是设置变量）的命令时，会检查其值是否已存在。如果已经存在，会将其重用</p>
</li>
<li><p>也就是说，遇到初始化对象的命令时，会将初始化的这个变量与值存储在一个字典中</p>
</li>
<li><p>遇到新的变量时，会先在字典中查询。如果有同样的记录，那么会重复使用字典中之前的这个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i1 = <span class="number">100</span></span><br><span class="line">i2 = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(id(i1))  <span class="comment"># 1407285088</span></span><br><span class="line">print(id(i2))  <span class="comment"># 1407285088</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意与上面 i1 = 1000 那个例子比较看结果</span></span><br><span class="line"><span class="comment"># 程序执行时会把 i1、i2 两个变量指向同一个对象</span></span><br><span class="line"><span class="comment"># 如果满足缓存机制则它们在内存中只存在一个，即它们的 id 相同。</span></span><br><span class="line"><span class="comment"># 注意这里重点是在同一个代码块下！</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(a <span class="keyword">is</span> b)   <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>代码块的缓存机制适用范围（数据类型）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int(float)		任何数字在同一个代码块中都会被复用</span><br><span class="line">str			    几乎所有的字符串都符合缓存机制</span><br><span class="line">bool		    True 和 False 会在字典中以 1 和 0 的方式存在，并且复用</span><br></pre></td></tr></table></figure>
</li>
<li><p>非乘法得到的字符串都满足代码块的缓存机制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">"as12$%#$"</span></span><br><span class="line">s2 = <span class="string">"as12$%#$"</span></span><br><span class="line"></span><br><span class="line">print(s1 <span class="keyword">is</span> s2)    <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里是在同一个代码块里</span></span><br><span class="line"><span class="comment"># 如果在终端内运行的话相当于在不同代码块里，结果就变了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>乘法得到的字符串分两种情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 乘数为1时，任何字符串满足代码块的缓存机制：</span></span><br><span class="line"></span><br><span class="line">b1 = <span class="string">'文字@5847395QQ0743895*&amp;^%$#((&amp;_+(())'</span> * <span class="number">1</span></span><br><span class="line">a1 = <span class="string">'文字@5847395QQ0743895*&amp;^%$#((&amp;_+(())'</span> * <span class="number">1</span></span><br><span class="line">print(a1 <span class="keyword">is</span> b1)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 乘数 &gt;= 2时：仅含大小写字母，数字，下划线，总长度 &lt;= 20，满足代码块的缓存机制：</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">'old_'</span> * <span class="number">5</span></span><br><span class="line">s2 = <span class="string">'old_'</span> * <span class="number">5</span></span><br><span class="line">print(s1 <span class="keyword">is</span> s2)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优点：</span></span><br><span class="line"><span class="comment"># 	能够提升一些字符串、整数处理事务时在时间和空间上的性能；</span></span><br><span class="line"><span class="comment">#	需要值相同的字符串、整数的时候，直接从‘字典’中取出复用，避免频繁的创建和销毁，提升效率，节约内存。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="小数据池"><a href="#小数据池" class="headerlink" title="小数据池"></a>小数据池</h2><ol>
<li>小数据池，也称为小整数缓存机制，或者称为驻留机制等等<ul>
<li>大前提：小数据池也是只针对 <code>int(float)</code>，<code>str</code>，<code>bool</code></li>
</ul>
</li>
<li><p>注意，小数据池是针对不同代码块之间的缓存机制</p>
</li>
<li><p><code>Python</code> 自动将 <code>-5~256</code> 的整数进行了缓存</p>
<ul>
<li>当将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象</li>
</ul>
</li>
<li><p><code>Python</code> 会将一定规则的字符串在字符串驻留池中，创建一份</p>
<ul>
<li>当将这些字符串赋值给某个变量时，并不会重新创建对象</li>
<li>而是使用在字符串驻留池中创建好的对象</li>
</ul>
</li>
<li><p>其实，无论是缓存还是字符串驻留池，都是 <code>Python</code>做的一个优化</p>
<ul>
<li>本质就是将 <code>-5-256</code> 的整数，和一定规则的字符串，放在一个池（容器，或者字典）中</li>
<li>无论程序中哪些变量指向这些范围内的整数或者字符串</li>
<li>都会直接在这个池中引用，即在内存中之创建一个</li>
<li>优点：<ul>
<li>能够提高一些字符串、整数处理人物在时间和空间上的性能</li>
<li>需要值相同的字符串、整数的时候，直接从池里拿来用</li>
<li>这样能避免频繁的创建和销毁，提升效率，节约内存</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int</code>：对于整数来说，小数据池的范围是 <code>- 5~256</code> </p>
<ul>
<li>如果多个变量都是指向同一个（在这个范围内的）数字</li>
<li>它们在内存中指向的都是一个内存地址</li>
</ul>
</li>
<li><code>str</code> : <ul>
<li>字符串的长度为 0 或者 1，默认都采用了驻留机制（小数据池）</li>
<li>字符串的长度 &gt; 1, 且只含有大小写字母，数字，下划线时，才会默认驻留。</li>
</ul>
</li>
<li>小结:<ul>
<li>如果在同一代码块下，则采用同一代码块下的缓存机制</li>
<li>如果是不同代码块，则采用小数据池的驻留机制。</li>
</ul>
</li>
</ol>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ol>
<li><p>之前提过 <code>ASCII</code>、<code>Unicode</code>、<code>UTF-8</code>、<code>GBK</code> 这四种编码</p>
</li>
<li><p>不同的编码之间不能互相识别（报错或出现乱码），不能相互转化</p>
</li>
<li><p>国际通用标准：文字通过网络传输，或者硬盘存储等不能使用 <code>Unicode</code> 编码方式，因为 <code>Unicode</code> 都是使用升级版 32 位的，太费流量了</p>
</li>
<li><p>在 <code>Python3x</code> 环境下，唯独 <code>str</code> 类型在内存中的编码方式是 <code>Unicode</code>，所以字符串不能直接进行网络传输及文件的存储</p>
</li>
<li><p><code>bytes</code> —— 数据类型，不是字节，与 <code>str</code> 类型就像是一对孪生兄弟</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">"alex"</span></span><br><span class="line">s2 = <span class="string">b"alex"</span></span><br><span class="line"></span><br><span class="line">print(type(s1))    <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">print(type(s2))    <span class="comment"># &lt;class 'bytes'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么为啥要有 bytes ?</span></span><br><span class="line"><span class="comment"># 因为 bytes 内部编码非 Unicode 方式，因此可以进行网络传输和文件的存储</span></span><br><span class="line"><span class="comment"># 前面提到，str 类型却是 Unicode 方式，那为什么不用 bytes 而是用 str?</span></span><br><span class="line"><span class="comment"># 因为，bytes 中文是 16 进制</span></span><br><span class="line"><span class="comment"># 当需要网络传输数据，文件存储数据时要考虑用 bytes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>str</code> 与 <code>bytes</code> 类型的相互转化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 英文</span></span><br><span class="line"><span class="comment">#    str 的表现形式："alex"</span></span><br><span class="line"><span class="comment">#          内部编码: Unicode</span></span><br><span class="line"><span class="comment"># 中文</span></span><br><span class="line"><span class="comment">#    str 的表现形式: "中文"</span></span><br><span class="line"><span class="comment">#          内部编码：Unicode</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由以上信息，str 转化成 bytes 的方法是:</span></span><br><span class="line"><span class="comment"># Unicode --&gt; GBK 字符串 --&gt; GBK 编码方式的 bytes</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"中国"</span>  </span><br><span class="line"><span class="comment"># 因为PythOn3x中 str 编码方式就是 Unicode，所以这里等同于 s = u"中国"</span></span><br><span class="line">a = s.encode(<span class="string">"gbk"</span>)</span><br><span class="line">print(s, type(s))     <span class="comment"># ('中国', &lt;class 'str'&gt;)</span></span><br><span class="line">print(a, type(a))     <span class="comment"># (b'\xd6\xd0\xb9\xfa', &lt;class 'bytes'&gt;)</span></span><br><span class="line"></span><br><span class="line">s1 = a.decode(<span class="string">"gbk"</span>)  <span class="comment"># 注意这里是 decode</span></span><br><span class="line">print(s1, type(s1))   <span class="comment"># ('中国', &lt;class 'str'&gt;)</span></span><br><span class="line"><span class="comment"># s = "中国" 是以 Unicode 编码方式的 str</span></span><br><span class="line"><span class="comment"># a = s.encode("gbk") 是将 Unicode 编码方式的 str 转化成 以 GBK 编码方式的 bytes</span></span><br><span class="line"><span class="comment"># s1 = a.decode("gbk") 则将 GBK 编码方式的 bytes 转化成 以 Unicode 编码方式的 str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># encode 编码</span></span><br><span class="line"><span class="comment"># decode 解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unicode --&gt; utf-8 字符串 --&gt; utf-8 编码方式的 bytes</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">"语言"</span></span><br><span class="line">b = s2.encode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(b, type(b))     <span class="comment"># (b'\xe8\xaf\xad\xe8\xa8\x80', &lt;class 'bytes'&gt;)</span></span><br><span class="line">s3 = b.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(s3, type(s3))   <span class="comment"># ('语言', &lt;class 'str'&gt;)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">shawnhuang90s</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.shawnhuang90s.tech/2019/05/03/Python03/">http://www.shawnhuang90s.tech/2019/05/03/Python03/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.shawnhuang90s.tech">Shawnhuang90s' Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/05/02/Python02/"><span>Python 基础知识(二)</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.postimg.cc/MHJ94GhS/timg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By shawnhuang90s</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>